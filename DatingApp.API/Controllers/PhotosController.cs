using System.Linq;
using System.Security.Claims;
using System.Threading.Tasks;
using AutoMapper;
using CloudinaryDotNet;
using CloudinaryDotNet.Actions;
using DatingApp.API.Data;
using DatingApp.API.Dtos;
using DatingApp.API.Helpers;
using DatingApp.API.Models;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Options;

namespace DatingApp.API.Controllers
{
  [Authorize]
  [Route("api/users/{userId}/photos")]
  [ApiController]
  public class PhotosController : ControllerBase
  {
    private readonly IDatingRepository _repo;
    private readonly IMapper _mapper;
    private readonly IOptions<CloudinarySettings> _cloudinaryConfig;
    private Cloudinary _cloudinary;

    public PhotosController(IDatingRepository repo, IMapper mapper, IOptions<CloudinarySettings> cloudinaryConfig)
    {
      _cloudinaryConfig = cloudinaryConfig;
      _mapper = mapper;
      _repo = repo;

      // Set up new Account for Cloudinary using the values set in appsettings.json and mapped in the CloudinarySettings class in startup.cs
      Account acc = new Account(
          _cloudinaryConfig.Value.CloudName,
          _cloudinaryConfig.Value.ApiKey,
          _cloudinaryConfig.Value.ApiSecret
      );

      // Create instance of Cloudinary and pass account details to it
      _cloudinary = new Cloudinary(acc);
    }

    //this is the route to get a photo that is used in the CreatedAtRoute returned from the post route below, it needs a Name to use in that method
    [HttpGet("{id}", Name = "GetPhoto")]
    public async Task<IActionResult> GetPhoto(int id)
    {
      var photoFromRepo = await _repo.GetPhoto(id);
      //this above returns a photo from the context/db which has other props on it we don't want.  We need to create a photo to return with the props we want
      // this dto is created and returned here to prevent props on the photo from repo being returned since we don't need all of them
      var photo = _mapper.Map<PhotoForReturnDto>(photoFromRepo);
      return Ok(photo);

    }

    //Note: the [FromForm] is used to tell Dotnet that the body and data is coming from form data (in this case it is a file) - this might be necessary to prevent model errors that are not resolved by the ApiController
    [HttpPost] // note that the paramter userId is already set in the main route config at the top of this file, so that's where the first arg is coming from
    public async Task<IActionResult> AddPhotoForUser(int userId, [FromForm] PhotoForCreationDto photoForCreationDto)
    {
      // the claim types on a user which contain the authorized user's id is stored as a string and it needs to be parsed to an into for comparison to the id in the url param
      if (userId != int.Parse(User.FindFirst(ClaimTypes.NameIdentifier).Value))
        return Unauthorized();

      var userFromRepo = await _repo.GetUser(userId);

      var file = photoForCreationDto.File;
      // this variable is used to store the result we get bak from Cloudinary
      var uploadResult = new ImageUploadResult();

      // check that there is something inside the file first: (Length is number of bytes)      
      if (file.Length > 0)
      {
        // Read the file into memory - using is used here to dispose of the file in memory used in this filestream once the method is done
        //OpenReadStream reads the file into memory
        using (var stream = file.OpenReadStream())
        {
          // create a Cloudinary compatible upload object using the stream read into memory to send to Cloudinary
          var uploadParams = new ImageUploadParams()
          {
            File = new FileDescription(file.Name, stream),
            // use the transformation to crop the image and focus on the users face if the file is too long
            Transformation = new Transformation().Width(500).Height(500).Crop("fill").Gravity("face")
          };
          uploadResult = _cloudinary.Upload(uploadParams);
        };
      }

      //Now start populating the Dto with information from the upload result from Cloudinary
      photoForCreationDto.Url = uploadResult.Uri.ToString();
      photoForCreationDto.PublicId = uploadResult.PublicId;
      // map the dto into the photo model based on the new properties just added.  the first arg passed in is the destination and the second arg passed into the method is the source
      var photo = _mapper.Map<Photo>(photoForCreationDto);

      // if the user has no photos then none are main - check this and if so, then make the first photo uploaded the main photo for the user
      if (!userFromRepo.Photos.Any(p => p.IsMain))
      {
        photo.IsMain = true;
      }

      userFromRepo.Photos.Add(photo);

      if (await _repo.SaveAll())
      {
        //NOTE: the photo will not have an id generated by the db until after the save is complete, so it is mapped here inside the if on successful save.
        var photoToReturn = _mapper.Map<PhotoForReturnDto>(photo);

        // response from a post should return a CreatedAtRoute response which automatically does include a location header with the location of the created resource (the url to your api to get the photo - myapi.com/api/users/1/photos)
        // you can use this location to perform a get request to that endpoint
        // the first overload in this method is the route to get a photo - this is created up above in this class, 
        // first parameter is you need to give the route a NAme to pass in which is done above on the route config
        //the second param or third overload is the id of the photo and core 3.0 also needs the userId
        //third param is the photo itself, use the dto to return the mapped props we want 
        return CreatedAtRoute("GetPhoto", new { userId = userId, id = photo.Id }, photoToReturn);
      }

      return BadRequest("Could not update Photo.");
    }
  }
}
